library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity uart_ram is
   generic(
		constant DATA_WIDTH      : natural := 16;
		constant ADDRESS_WIDTH   : natural := 23
	);
	port(      
      clk: in std_logic;
      -- uart
      RsRx: in std_logic;
      RsTx: out std_logic;
		-- inputs
      sw: in std_logic_vector(7 downto 0);
		btn: in std_logic_vector(3 downto 0);
      -- outputs
		an: out std_logic_vector(3 downto 0);
      sseg: out std_logic_vector(7 downto 0);
		-- to SRAM
		MemOE: out std_logic;
		MemWR: out std_logic;
		RamAdv: out std_logic;
		RamCS: out std_logic;
		RamClk: out std_logic;
		RamCRE: out std_logic;
		RamLB: out std_logic;
		RamUB: out std_logic;
		MemAdr: out std_logic_vector(ADDRESS_WIDTH-1 downto 0);
		MemDB: inout std_logic_vector(DATA_WIDTH-1 downto 0)
   );
end uart_ram;

architecture arch of uart_ram is
   
	constant CYCLES_TO_WAIT  : natural := 5;
	constant CYCLES_TO_WAIT_WIDTH : natural := 3;
	
	signal data_reg: std_logic_vector(7 downto 0);
   signal db_btn: std_logic_vector(3 downto 0);
	
   -- seven segment
   signal led3, led2, led1, led0: std_logic_vector(7 downto 0);
	
   -- ram
   signal reset: std_logic := '0';
	signal mem: std_logic := '0';
	signal rw: std_logic := '1';
	signal address_in: std_logic_vector(ADDRESS_WIDTH-1 downto 0) := (others => '0');
	signal data_in: std_logic_vector(DATA_WIDTH-1 downto 0) := (others => '0');
	signal ready: std_logic;
   signal data_out: std_logic_vector(DATA_WIDTH-1 downto 0);
   
   -- uart
   signal rd_uart, wr_uart: std_logic := '0';
   signal tx_full, rx_empty: std_logic;
   signal w_data: std_logic_vector(7 downto 0);
   signal r_data: std_logic_vector(7 downto 0);
   signal data_buffer: std_logic_vector(7 downto 0);

   -- state machine
   type state_t is (waiting_for_uart, write_sram, waiting_for_sram);
   signal state : state_t := waiting_for_uart;
   signal address_current, address_next: unsigned(ADDRESS_WIDTH-1 downto 0) := (others => '0');
   signal mem_current, mem_next: std_logic := '0';
   signal rw_current, rw_next: std_logic := '0';
   signal data_in_current, data_in_next: std_logic_vector(DATA_WIDTH-1 downto 0) := (others => '0');

   type major_state_t is (writing_from_uart, writing_from_switches);
   signal major_state : major_state_t := writing_from_uart;

begin

   -- instantiate uart
   uart_unit: entity work.uart(str_arch)
   port map(
       clk =>  clk, reset =>  reset, rd_uart =>  rd_uart,
       wr_uart =>  rd_uart, rx =>  RsRx, w_data =>  r_data,
       tx_full => tx_full, rx_empty =>  rx_empty,
       r_data =>  r_data, tx =>  RsTx
   );

   -- instantiate ram controller
	sram: entity work.sram_controller
	port map (
		clk => clk,
		reset => reset,
		-- to/from main system
      mem => mem, rw => rw, address_in => address_in, data_in => data_in,
      ready => ready, data_out => data_out,
		-- to/from SRAM
		address_to_sram => MemAdr, data_to_sram => MemDB, clk_out => RamClk, adv => RamAdv,
		ce => RamCS, oe => MemOE, we => MemWR, cre => RamCRE, lb => RamLB, ub => RamUB
	);

   -- instantiate four instances of hex decoders
   sseg_unit_0: entity work.hex_to_sseg
      port map(hex=>data_out(3 downto 0), dp =>'1', sseg=>led0);
   sseg_unit_1: entity work.hex_to_sseg
      port map(hex=>data_out(7 downto 4), dp =>'1', sseg=>led1);
   sseg_unit_2: entity work.hex_to_sseg
      port map(hex=>data_out(11 downto 8), dp =>'1', sseg=>led2);
   sseg_unit_3: entity work.hex_to_sseg
      port map(hex=>data_out(15 downto 12), dp =>'1', sseg=>led3);

   -- instantiate 7-seg LED display time-multiplexing module
   disp_unit: entity work.disp_mux
      port map(
         clk=>clk, reset=>'0',
         in0=>led0, in1=>led1, in2=>led2, in3=>led3,
         an=>an, sseg=>sseg);

   -- instantiate 4 debouncers
   debounce_unit0: entity work.debounce
      port map(
         clk=>clk, reset=>reset, sw=>btn(0),
         db_level=>open, db_tick=>db_btn(0)
      );
   debounce_unit1: entity work.debounce
      port map(
         clk=>clk, reset=>reset, sw=>btn(1),
         db_level=>open, db_tick=>db_btn(1));
   debounce_unit2: entity work.debounce
      port map(
         clk=>clk, reset=>reset, sw=>btn(2),
         db_level=>open, db_tick=>db_btn(2));
   debounce_unit3: entity work.debounce
      port map(
         clk=>clk, reset=>reset, sw=>btn(3),
         db_level=>open, db_tick=>db_btn(3));

   uart_to_ram: process (clk)
   begin
      rw <= '0';
      if (clk'event and clk='1') then
         if (db_btn(0)='1') then
            data_reg <= sw;
         end if;
         if (db_btn(3)='1') then
            if major_state = writing_from_uart then
               major_state <= writing_from_switches;
            else
               major_state <= writing_from_uart;
            end if;
         end if;
         case major_state is
            when writing_from_uart =>
               case state is
                  when waiting_for_uart =>
                     if rx_empty = '0' then
                        state <= write_sram;
                     else
                        state <= waiting_for_uart;
                     end if;
                  when write_sram =>
                     if mem = '0' then
                        mem <= '1';
                        rw <= '1';
                        data_in <= r_data;
                        address_in <= std_logic_vector(address_current);
                        state <= write_sram;
                     else
                        mem <= '0';
                        state <= waiting_for_sram;
                     end if;
                  when waiting_for_sram =>
                     if ready = '1' then
                        state <= echo_byte;
                        rd_uart <= '1';
                        address_current <= address_current + to_unsigned(1, address_current'length);
                     else
                        state <= waiting_for_sram;
                     end if;
                  when echo_byte =>
                     rd_uart <= '0';
                     state <= waiting_for_uart;
               end case;
            when writing_from_switches =>
               data_in <= (others=>'0');
               address_in <= "0000000000" & sw;
               if db_btn(1)='1' then -- write
                  mem <= '1';
                  rw <= '0';
                  data_in <= "00000000" & data_reg;
               elsif db_btn(2)='1' then -- read
                  mem <= '1';
                  rw <= '1';
               else
                  mem <= '0';
                  rw <= '1';
               end if;
            end case;
      end if;
   end process;

end arch;